<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Pickleball Catch!</title>
  <style>
    body { 
      margin: 0; 
      padding: 0;
      overflow: hidden; 
      background: black; 
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      min-height: 100dvh; /* 動的ビューポート対応 */
    }
    canvas { 
      display: block; 
      background: black;
      max-width: 100vw;
      max-height: 100vh;
      max-height: 100dvh; /* 動的ビューポート対応 */
    }
    #muteButton {
      position: absolute;
      top: 10px;
      right: 10px;
      z-index: 100;
      background: rgba(255,255,255,0.8);
      border: none;
      border-radius: 50%;
      width: 40px;
      height: 40px;
      font-size: 16px;
      cursor: pointer;
    }
    
    /* フルスクリーン用スタイル */
    @media screen and (max-height: 500px) {
      body {
        min-height: 100dvh;
      }
    }
  </style>
  <link href="https://fonts.googleapis.com/css2?family=Fredoka+One&display=swap" rel="stylesheet">
</head>
<body>
  <button id="muteButton">🔊</button>
  <canvas id="gameCanvas"></canvas>
  <script>
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");
    const muteBtn = document.getElementById("muteButton");

    // 動的比率対応設定
    const MIN_ASPECT_RATIO = 16 / 9;  // 最小比率（PC用）
    const MAX_ASPECT_RATIO = 2.5 / 1; // 最大比率（超ワイドスマホ対応）
    const BASE_WIDTH = 1600;
    const BASE_HEIGHT = 900;

    function resizeCanvas() {
      const windowWidth = window.innerWidth;
      const windowHeight = window.innerHeight;
      
      // デバイスの実際の比率を計算
      const deviceAspectRatio = windowWidth / windowHeight;
      
      // 比率を制限内に収める
      const targetAspectRatio = Math.max(MIN_ASPECT_RATIO, 
                                Math.min(MAX_ASPECT_RATIO, deviceAspectRatio));
      
      let canvasWidth, canvasHeight;
      
      // 常に画面全体を使用（95%のマージン）
      if (deviceAspectRatio > targetAspectRatio) {
        // 横が余る場合
        canvasHeight = windowHeight * 0.95;
        canvasWidth = canvasHeight * targetAspectRatio;
      } else {
        // 縦が余る場合
        canvasWidth = windowWidth * 0.98;
        canvasHeight = canvasWidth / targetAspectRatio;
        
        if (canvasHeight > windowHeight * 0.95) {
          canvasHeight = windowHeight * 0.95;
          canvasWidth = canvasHeight * targetAspectRatio;
        }
      }
      
      // Canvasの内部サイズを比率に合わせて動的に調整
      const dynamicWidth = BASE_WIDTH;
      const dynamicHeight = Math.round(BASE_WIDTH / targetAspectRatio);
      
      canvas.width = dynamicWidth;
      canvas.height = dynamicHeight;
      canvas.style.width = canvasWidth + 'px';
      canvas.style.height = canvasHeight + 'px';
      
      // ゲーム内で使用する実際の高さを更新
      window.GAME_HEIGHT = dynamicHeight;
    }

    window.addEventListener("resize", resizeCanvas);
    resizeCanvas();

    // サウンド管理（シンプル版）
    let isMuted = false;
    const bgm = new Audio("bgm.mp3");
    bgm.loop = true;
    bgm.volume = 0.2;
    
    const catchNormalSound = new Audio("catch_normal.wav");
    const catchRareSound = new Audio("catch_rare.wav");
    const missSound = new Audio("miss.mp3");
    const gameoverSound = new Audio("gameover.mp3");

    muteBtn.addEventListener("click", () => {
      isMuted = !isMuted;
      muteBtn.textContent = isMuted ? "🔇" : "🔊";
      
      if (isMuted) {
        bgm.pause();
        bgmDebugInfo = "BGM muted by user";
      } else {
        if (userInteracted) {
          startBGM();
        }
      }
      
      // 他の音声もミュート設定
      catchNormalSound.muted = isMuted;
      catchRareSound.muted = isMuted;
      missSound.muted = isMuted;
      gameoverSound.muted = isMuted;
    });

    // 画像読み込み
    const bgImg = new Image(); bgImg.src = "bg.png";
    const titleImg = new Image(); titleImg.src = "title.png";
    const paddleImg = new Image(); paddleImg.src = "paddle.png";
    
    const ballImgs = {};
    const ballColors = ["pink", "orange", "lightblue", "blue", "green", "yellow", "rainbow"];
    ballColors.forEach(color => {
      const img = new Image();
      img.src = `${color}.png`;
      ballImgs[color] = img;
    });

    // ゲーム状態
    let gameState = "title";
    let score = 0, highScore = 0, lives = 3;
    let paddle = { x: 0, y: 0, width: 225, height: 60 }; // パドルサイズ1.5倍（150x40 → 225x60）
    let balls = [];
    let effects = []; // レインボーボール用エフェクト
    let lastSpawn = 0, maxBalls = 2, startTime = null;

    // ボール設定（サイズ調整、速度調整）
    const BALL_SIZE = 180; // ボールサイズを180pxに
    const ballTypes = {
      pink: { speed: 2, score: 1 },       // 2固定
      orange: { speed: 4, score: 1 },     // 2+2=4
      lightblue: { speed: 6, score: 1 },  // 4+2=6
      blue: { speed: 8, score: 1 },       // 6+2=8
      green: { speed: 10, score: 1 },     // 8+2=10
      yellow: { speed: 12, score: 1 },    // 10+2=12
      rainbow: { speed: 25, score: 10, rare: true } // 25固定
    };

    // 入力処理
    function getCanvasCoordinate(clientX, clientY) {
      const rect = canvas.getBoundingClientRect();
      const scaleX = BASE_WIDTH / rect.width;
      const scaleY = BASE_HEIGHT / rect.height;
      return {
        x: (clientX - rect.left) * scaleX,
        y: (clientY - rect.top) * scaleY
      };
    }

    window.addEventListener("mousemove", e => {
      if (gameState !== "playing") return;
      const coord = getCanvasCoordinate(e.clientX, e.clientY);
      paddle.x = coord.x - paddle.width / 2;
      clampPaddle();
    });

    window.addEventListener("touchmove", e => {
      if (gameState !== "playing") return;
      e.preventDefault();
      const touch = e.touches[0];
      const coord = getCanvasCoordinate(touch.clientX, touch.clientY);
      paddle.x = coord.x - paddle.width / 2;
      clampPaddle();
    }, { passive: false });

    function clampPaddle() {
      if (paddle.x < 0) paddle.x = 0;
      if (paddle.x + 300 > BASE_WIDTH) {  // パドルサイズ300に合わせて調整
        paddle.x = BASE_WIDTH - 300;
      }
    }

    // BGM管理用変数
    let userInteracted = false;
    let bgmDebugInfo = "BGM waiting for interaction";

    // BGM開始関数（確実に再生）
    function startBGM() {
      if (!isMuted) {
        bgmDebugInfo = "Starting BGM...";
        bgm.currentTime = 0;
        
        // 強制的にBGM再生を試行
        const playPromise = bgm.play();
        if (playPromise !== undefined) {
          playPromise.then(() => {
            bgmDebugInfo = "BGM playing successfully";
            console.log("BGM started successfully");
          }).catch(error => {
            bgmDebugInfo = `BGM error: ${error.name}`;
            console.log("BGM failed:", error);
            
            // 短時間後に再試行
            setTimeout(() => {
              bgm.play().then(() => {
                bgmDebugInfo = "BGM retry successful";
              }).catch(() => {
                bgmDebugInfo = "BGM retry failed";
              });
            }, 200);
          });
        }
      } else {
        bgmDebugInfo = "BGM muted";
      }
    }

    canvas.addEventListener("click", e => {
      e.preventDefault();
      
      if (!userInteracted) {
        userInteracted = true;
        bgmDebugInfo = "First click - starting BGM";
        startBGM();
      }
      
      const coord = getCanvasCoordinate(e.clientX, e.clientY);
      
      if (gameState === "title") {
        startGame();
      } else if (gameState === "gameover") {
        startGame();
      }
    });

    canvas.addEventListener("touchstart", e => {
      e.preventDefault();
      
      if (!userInteracted) {
        userInteracted = true;
        bgmDebugInfo = "First touch - starting BGM";
        startBGM();
      }
      
      const touch = e.touches[0];
      const coord = getCanvasCoordinate(touch.clientX, touch.clientY);
      
      if (gameState === "title") {
        startGame();
      } else if (gameState === "gameover") {
        startGame();
      }
    });

    function startGame() {
      gameState = "playing";
      score = 0; 
      lives = 3;
      balls = [];
      effects = [];
      maxBalls = 2;
      startTime = Date.now();
      lastSpawn = 0;
      
      // ゲームオーバーサウンドを停止
      gameoverSound.pause();
      gameoverSound.currentTime = 0;
      
      // ゲーム開始時にBGM状態確認・再生
      bgmDebugInfo = "Game starting...";
      
      if (!isMuted && userInteracted) {
        // BGMが停止している場合は再開
        if (bgm.paused) {
          bgmDebugInfo = "Restarting paused BGM";
          bgm.currentTime = 0;
          bgm.play().then(() => {
            bgmDebugInfo = "BGM restarted in game";
          }).catch(error => {
            bgmDebugInfo = `BGM restart failed: ${error.name}`;
          });
        } else {
          bgmDebugInfo = "BGM already playing";
        }
      }
    }

    // ボール出現ルール
    function getAvailableColors(elapsed) {
      const colors = [];
      
      // 序盤（0〜15秒）
      colors.push("orange", "lightblue", "blue");
      
      // 15秒〜30秒：緑追加
      if (elapsed >= 15) colors.push("green");
      
      // 30秒〜45秒：ピンク追加
      if (elapsed >= 30) colors.push("pink");
      
      // 45秒〜60秒：黄追加
      if (elapsed >= 45) colors.push("yellow");
      
      return colors;
    }

    function spawnBall() {
      const elapsed = (Date.now() - startTime) / 1000;
      
      // レインボーは常時低確率（3%）
      if (Math.random() < 0.03) {
        const ball = { 
          x: Math.random() * (BASE_WIDTH - 180), 
          y: -180, 
          size: 180, 
          type: "rainbow" 
        };
        balls.push(ball);
        return;
      }
      
      // 通常のボール
      const availableColors = getAvailableColors(elapsed);
      const color = availableColors[Math.floor(Math.random() * availableColors.length)];
      
      balls.push({ 
        x: Math.random() * (BASE_WIDTH - 180), 
        y: -180, 
        size: 180, 
        type: color 
      });
    }

    // レインボーボール用エフェクト
    function addRainbowEffect(ball) {
      for (let i = 0; i < 3; i++) {
        effects.push({
          x: ball.x + ball.size/2 + (Math.random() - 0.5) * 40,
          y: ball.y + ball.size/2,
          size: Math.random() * 8 + 4,
          alpha: 1,
          color: `hsl(${Math.random() * 360}, 100%, 70%)`
        });
      }
    }

    function updateEffects() {
      effects.forEach((effect, i) => {
        effect.y += 2;
        effect.alpha -= 0.03;
        if (effect.alpha <= 0) {
          effects.splice(i, 1);
        }
      });
    }

    function drawEffects() {
      effects.forEach(effect => {
        ctx.save();
        ctx.globalAlpha = effect.alpha;
        ctx.fillStyle = effect.color;
        ctx.beginPath();
        ctx.arc(effect.x, effect.y, effect.size, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      });
    }

    // パドルとボールの当たり判定（外枠のみ、パドル画像の実際の境界に合わせて調整）
    function checkCollision(ball, paddle) {
      const ballLeft = ball.x;
      const ballRight = ball.x + ball.size;
      const ballTop = ball.y;
      const ballBottom = ball.y + ball.size;
      
      const paddleLeft = paddle.x;
      const paddleRight = paddle.x + 300; // パドルの幅
      const paddleTop = paddle.y + 25; // パドル画像の実際の上端（透明部分を除く、さらに下に調整）
      const paddleBottom = paddle.y + 80; // パドルの高さ
      
      // ボールがパドルの範囲内にあるかチェック
      if (ballRight < paddleLeft || ballLeft > paddleRight || 
          ballBottom < paddleTop || ballTop > paddleBottom) {
        return false;
      }
      
      // 外枠との当たり判定
      // 上面との当たり判定（パドル画像の実際の境界）
      if (ballBottom >= paddleTop && ballTop < paddleTop && 
          ballRight > paddleLeft && ballLeft < paddleRight) {
        return true;
      }
      
      // 左面との当たり判定
      if (ballRight >= paddleLeft && ballLeft < paddleLeft && 
          ballBottom > paddleTop && ballTop < paddleBottom) {
        return true;
      }
      
      // 右面との当たり判定
      if (ballLeft <= paddleRight && ballRight > paddleRight && 
          ballBottom > paddleTop && ballTop < paddleBottom) {
        return true;
      }
      
      return false;
    }

    function update() {
      if (!startTime) startTime = Date.now();
      const elapsed = (Date.now() - startTime) / 1000;

      // ボール出現制御（超シビア設定）
      if (elapsed - lastSpawn > 0.5 && balls.length < maxBalls) {
        spawnBall(); 
        lastSpawn = elapsed;
      }
      
      // 強制出現システム：最大数に達していない場合は積極的に出現
      if (balls.length < maxBalls - 1 && elapsed - lastSpawn > 0.2) {
        spawnBall();
        lastSpawn = elapsed;
      }
      
      // 超強制出現：最大数の半分以下なら即座に出現
      if (balls.length < maxBalls / 2) {
        spawnBall();
        lastSpawn = elapsed;
      }
      
      // 難易度進行（15秒ごとに+1個、150秒で最大12個まで）
      // 0秒:2個 → 15秒:3個 → 30秒:4個 → 45秒:5個 → 60秒:6個 → 75秒:7個 → 90秒:8個 → 105秒:9個 → 120秒:10個 → 135秒:11個 → 150秒:12個
      const newMaxBalls = Math.min(12, 2 + Math.floor(elapsed / 15));
      if (newMaxBalls > maxBalls) {
        maxBalls = newMaxBalls;
      }

      paddle.y = (window.GAME_HEIGHT || BASE_HEIGHT) - 120;
      balls.forEach((ball, i) => {
        ball.y += ballTypes[ball.type].speed;
        
        // レインボーボールにエフェクト追加
        if (ball.type === "rainbow") {
          addRainbowEffect(ball);
        }
        
        // 当たり判定（外枠のみ）
        if (checkCollision(ball, paddle)) {
          score += ballTypes[ball.type].score;
          
          // サウンド再生（スマホ対応改善）
          const sound = ball.type === "rainbow" ? catchRareSound : catchNormalSound;
          if (!isMuted) {
            try {
              const audioClone = sound.cloneNode();
              audioClone.volume = 0.7; // 音量調整
              audioClone.currentTime = 0;
              audioClone.play().catch(e => console.log("Audio play failed:", e));
            } catch (e) {
              console.log("Audio clone failed:", e);
            }
          }
          
          balls.splice(i, 1);
        } else if (ball.y > (window.GAME_HEIGHT || BASE_HEIGHT)) {
          // ライフ減少（レインボーは除く）
          if (!ballTypes[ball.type].rare) {
            lives--;
            if (!isMuted) {
              const missClone = missSound.cloneNode();
              missClone.play();
            }
            if (lives <= 0) gameOver();
          }
          balls.splice(i, 1);
        }
      });

      updateEffects();
    }

    function gameOver() {
      gameState = "gameover";
      // BGMは停止せずに継続再生
      if (!isMuted) {
        gameoverSound.currentTime = 0; 
        gameoverSound.play();
      }
      if (score > highScore) highScore = score;
    }

    function draw() {
      const gameHeight = window.GAME_HEIGHT || BASE_HEIGHT;
      
      // 背景（動的サイズ対応）
      ctx.drawImage(bgImg, 0, 0, BASE_WIDTH, gameHeight);
      
      // パドル（下端からの相対位置）
      paddle.y = gameHeight - 120;
      ctx.drawImage(paddleImg, paddle.x, paddle.y, 300, 80);
      
      // ボール
      balls.forEach(ball => {
        ctx.drawImage(ballImgs[ball.type], ball.x, ball.y, ball.size, ball.size);
      });
      
      // エフェクト
      drawEffects();
      
      // UI
      ctx.fillStyle = "white";
      ctx.font = "64px 'Fredoka One'";
      ctx.textAlign = "center";
      ctx.fillText("Score: " + score, BASE_WIDTH/2, 80);
      
      // ライフ表示（赤色、2倍サイズ、位置を下に調整）
      ctx.fillStyle = "red";
      ctx.font = "96px 'Fredoka One'";
      ctx.fillText("♥".repeat(lives), BASE_WIDTH/2, 180);
      
      // BGMデバッグ情報をゲーム中も表示
      ctx.fillStyle = "yellow";
      ctx.font = "20px 'Fredoka One'";
      ctx.textAlign = "left";
      ctx.fillText(`BGM: ${bgmDebugInfo}`, 50, gameHeight - 50);
    }

    function drawTitleScreen() {
      const gameHeight = window.GAME_HEIGHT || BASE_HEIGHT;
      ctx.drawImage(titleImg, 0, 0, BASE_WIDTH, gameHeight);
      
      ctx.fillStyle = "#ff66cc"; // ピンク色
      ctx.font = "120px 'Fredoka One'";
      ctx.textAlign = "center";
      ctx.fillText("Pickleball Catch!", BASE_WIDTH/2, gameHeight/2 - 60);
      
      // 点滅効果
      if (Math.floor(Date.now() / 500) % 2 === 0) {
        ctx.fillStyle = "white";
        ctx.font = "64px 'Fredoka One'";
        ctx.fillText("Tap to Start!", BASE_WIDTH/2, gameHeight/2 + 60);
      }
      
      // BGMデバッグ情報表示
      ctx.fillStyle = "yellow";
      ctx.font = "24px 'Fredoka One'";
      ctx.textAlign = "left";
      ctx.fillText(`BGM Status: ${bgmDebugInfo}`, 50, 50);
      ctx.fillText(`Mute Button: ${isMuted ? 'Muted' : 'Unmuted'}`, 50, 80);
    }

    function drawGameOver() {
      const gameHeight = window.GAME_HEIGHT || BASE_HEIGHT;
      
      ctx.fillStyle = "rgba(0,0,0,0.7)";
      ctx.fillRect(0, 0, BASE_WIDTH, gameHeight);
      
      ctx.textAlign = "center";
      
      // GAME OVER
      ctx.fillStyle = "#ff66cc"; // ピンク
      ctx.font = "140px 'Fredoka One'";
      ctx.fillText("GAME OVER", BASE_WIDTH/2, gameHeight/2 - 120);
      
      // スコア
      ctx.fillStyle = "#ff66cc"; // ピンク
      ctx.font = "80px 'Fredoka One'";
      ctx.fillText("Score: " + score, BASE_WIDTH/2, gameHeight/2 - 20);
      
      // ハイスコア
      ctx.fillStyle = "#ffcc00"; // 黄色
      ctx.fillText("High Score: " + highScore, BASE_WIDTH/2, gameHeight/2 + 60);
      
      // タップでリスタートの指示（点滅効果）
      if (Math.floor(Date.now() / 500) % 2 === 0) {
        ctx.fillStyle = "white";
        ctx.font = "48px 'Fredoka One'";
        ctx.fillText("Tap anywhere to restart", BASE_WIDTH/2, gameHeight/2 + 150);
      }
    }

    function loop() {
      ctx.clearRect(0, 0, BASE_WIDTH, BASE_HEIGHT);
      
      if (gameState === "title") {
        drawTitleScreen();
      } else if (gameState === "playing") {
        update();
        draw();
      } else if (gameState === "gameover") {
        drawGameOver();
      }
      
      requestAnimationFrame(loop);
    }

    loop();
  </script>
</body>
</html>