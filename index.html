<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
<title>Pickleball Catch!</title>
<link href="https://fonts.googleapis.com/css2?family=Fredoka+One&display=swap" rel="stylesheet">
<style>
  :root { color-scheme: light dark; }
  html, body {
    margin: 0; padding: 0; background: #000; overflow: hidden; height: 100%; width: 100%;
    touch-action: none; /* スマホでのスクロール/ダブルタップ拡大を抑止 */
  }
  canvas { display: block; margin: 0 auto; background: #000; }
  #muteBtn {
    position: fixed; left: 12px; top: 12px; z-index: 20;
    background: rgba(255,255,255,0.8); border: 0; border-radius: 12px;
    padding: 6px 10px; font-size: 18px; cursor: pointer;
  }
</style>
</head>
<body>
<button id="muteBtn" aria-label="mute">🔊</button>
<canvas id="game"></canvas>

<script>
/* =========================
   基本セットアップ
========================= */
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
let state = 'TITLE'; // TITLE | PLAYING | GAMEOVER

// 16:9固定キャンバス（画面いっぱい）
let scale = 1; // 1920x1080基準のスケール
function resizeCanvas() {
  let vw = window.innerWidth, vh = window.innerHeight;
  if (vw / vh > 16/9) {
    // 横に余る → 高さ基準
    canvas.height = vh;
    canvas.width  = Math.floor(vh * 16/9);
  } else {
    // 縦に余る → 幅基準
    canvas.width  = vw;
    canvas.height = Math.floor(vw * 9/16);
  }
  scale = canvas.width / 1920; // 1920x1080 を1.0とする
}
window.addEventListener('resize', resizeCanvas, { passive:true });
resizeCanvas();

/* =========================
   アセット
========================= */
// 画像
const imgBG = new Image(); imgBG.src = 'bg.png';
const imgTitle = new Image(); imgTitle.src = 'title.png';
const imgGameOver = new Image(); imgGameOver.src = 'gameover.png';
const imgPaddle = new Image(); imgPaddle.src = 'paddle.png';

const ballImgs = {
  pink:      new Image(),
  orange:    new Image(),
  lightblue: new Image(),
  blue:      new Image(),
  green:     new Image(),
  yellow:    new Image(),
  rainbow:   new Image()
};
ballImgs.pink.src      = 'pink.png';
ballImgs.orange.src    = 'orange.png';
ballImgs.lightblue.src = 'lightblue.png';
ballImgs.blue.src      = 'blue.png';
ballImgs.green.src     = 'green.png';
ballImgs.yellow.src    = 'yellow.png';
ballImgs.rainbow.src   = 'rainbow.png';

// 音
const sNormal   = new Audio('catch_normal.wav');
const sRare     = new Audio('catch_rare.wav');
const sMiss     = new Audio('miss.mp3');
const sGameOver = new Audio('gameover.mp3');
[sNormal, sRare, sMiss].forEach(a => a.volume = 0.8);
sGameOver.volume = 0.5;

// ミュート（保存）
let muted = (localStorage.getItem('pickleball_muted') === 'true');
function applyMute(m) {
  muted = m;
  localStorage.setItem('pickleball_muted', m ? 'true' : 'false');
  document.getElementById('muteBtn').textContent = m ? '🔇' : '🔊';
  [sNormal, sRare, sMiss, sGameOver].forEach(a => a.muted = m);
}
applyMute(muted);
document.getElementById('muteBtn').addEventListener('click', () => applyMute(!muted));

/* =========================
   ゲームオブジェクト
========================= */
let score = 0;
let highScore = parseInt(localStorage.getItem('pickleball_highscore') || '0', 10);
let lives = 3;
let balls = [];
let lastTime = performance.now();
let startTime = performance.now();
let spawnCooldown = 0;        // 次の生成までの時間(秒)
let spawnDelayMin = 0.35;     // 連続で同時湧きを防ぐための下限
let spawnDelayMax = 0.9;

const UI = {
  font(sizePx) { return `${Math.floor(sizePx*scale)}px 'Fredoka One', system-ui, sans-serif`; },
  centerText(text, y, color='#fff') {
    ctx.fillStyle = color;
    ctx.textAlign = 'center';
    ctx.fillText(text, canvas.width/2, y);
  }
};

// パドル（画面幅に応じて自動スケール）
const paddle = {
  wBase: 320, hBase: 64,
  x: 0, y: 0,
  get w(){ return this.wBase * scale; },
  get h(){ return this.hBase * scale; },
  update() {
    this.y = canvas.height - this.h*1.4;
    // 端からはみ出ない
    if (this.x < 0) this.x = 0;
    if (this.x + this.w > canvas.width) this.x = canvas.width - this.w;
  },
  draw() {
    ctx.drawImage(imgPaddle, this.x, this.y, this.w, this.h);
  }
};

// 入力（マウス / タッチ）
function movePaddleTo(clientX) {
  const rect = canvas.getBoundingClientRect();
  const x = clientX - rect.left - paddle.w/2;
  paddle.x = Math.min(Math.max(x, 0), canvas.width - paddle.w);
}
canvas.addEventListener('mousemove', e => { if (state==='PLAYING') movePaddleTo(e.clientX); });
canvas.addEventListener('touchmove', e => {
  if (state==='PLAYING') { movePaddleTo(e.touches[0].clientX); }
},{passive:true});
canvas.addEventListener('click', () => {
  if (state==='TITLE' || state==='GAMEOVER') startGame();
});

/* =========================
   ボール
========================= */
class Ball {
  constructor(type, speedPxPerSec) {
    this.type = type;
    this.img = ballImgs[type];
    this.sizeBase = 96; // 画像の見やすさ重視で大きめ
    this.size = this.sizeBase * scale;
    const margin = 6 * scale;
    this.x = margin + Math.random() * (canvas.width - this.size - margin*2);
    this.y = -this.size;
    // 速度は 1920x1080 基準のpx/secをスケール補正
    this.vy = Math.max(80, speedPxPerSec) * (canvas.height/1080);
  }
  update(dt) {
    this.y += this.vy * dt;
  }
  draw() {
    ctx.drawImage(this.img, this.x, this.y, this.size, this.size);
  }
  isOut() { return this.y > canvas.height; }
  hitPaddle() {
    // AABB判定（少し甘め）
    return (this.y + this.size >= paddle.y) &&
           (this.x + this.size >= paddle.x + this.size*0.15) && // 左側のすり抜け軽減
           (this.x <= paddle.x + paddle.w - this.size*0.15);
  }
}

// 出現ルール
function availableTypesAt(sec) {
  if (sec < 15) return ['orange','lightblue','blue'];
  if (sec < 30) return ['orange','lightblue','blue','green'];
  if (sec < 45) return ['orange','lightblue','blue','green','pink'];
  if (sec < 60) return ['orange','lightblue','blue','green','pink','yellow'];
  return ['orange','lightblue','blue','green','pink','yellow']; // 60秒以降：全色
}
// スピード（px/sec）基準（blueを標準とし、rainbow=3倍）
function speedFor(type) {
  switch(type){
    case 'pink':      return 120; // とてもゆっくり
    case 'orange':    return 180; // ゆっくり
    case 'lightblue': return 240; // 遅め
    case 'blue':      return 300; // 普通
    case 'green':     return 380; // 少し早い
    case 'yellow':    return 480; // 早い
    case 'rainbow':   return 300*3; // 激速（青の3倍）
  }
  return 300;
}

/* =========================
   ゲーム制御
========================= */
function startGame(){
  state = 'PLAYING';
  score = 0; lives = 3; balls.length = 0;
  startTime = performance.now();
  spawnCooldown = 0;
  // ゲームオーバー音をリセット
  sGameOver.pause(); sGameOver.currentTime = 0;

  // 初期パドル位置：中央
  paddle.x = (canvas.width - paddle.w)/2;
  paddle.update();
}

function gameOver(){
  state = 'GAMEOVER';
  if (score > highScore) {
    highScore = score;
    localStorage.setItem('pickleball_highscore', String(highScore));
  }
  if (!muted) { sGameOver.currentTime = 0; sGameOver.play().catch(()=>{}); }
}

// 経過時間(秒)と最大同時数
function elapsedSec() { return (performance.now() - startTime) / 1000; }
function maxConcurrentByTime(sec) { return Math.min(2 + Math.floor(sec / 10), 12); }

// 1体スポーン（低確率でレインボー）
function spawnOne(sec) {
  let types = availableTypesAt(sec).slice();
  if (Math.random() < 0.05) { // 5%でレインボー
    types = ['rainbow'];
  }
  const t = types[Math.floor(Math.random()*types.length)];
  const spd = speedFor(t);
  balls.push(new Ball(t, spd));
}

/* =========================
   ループ
========================= */
function update(dt){
  if (state !== 'PLAYING') return;

  const sec = elapsedSec();
  const maxN = maxConcurrentByTime(sec);

  // スポーン間隔制御（同時湧き防止）
  spawnCooldown -= dt;
  if (balls.length < maxN && spawnCooldown <= 0) {
    spawnOne(sec);
    spawnCooldown = randRange(spawnDelayMin, spawnDelayMax); // 次の湧きまでの間隔
  }

  // 更新
  for (let i = balls.length-1; i >= 0; i--) {
    const b = balls[i];
    b.update(dt);

    if (b.hitPaddle()) {
      // スコア & 音
      if (b.type === 'rainbow') {
        score += 10;
        if (!muted) { sRare.currentTime = 0; sRare.play().catch(()=>{}); }
      } else {
        score += 1;
        if (!muted) { sNormal.currentTime = 0; sNormal.play().catch(()=>{}); }
      }
      balls.splice(i,1);
      continue;
    }

    if (b.isOut()) {
      if (b.type !== 'rainbow') {
        lives -= 1;
        if (!muted) { sMiss.currentTime = 0; sMiss.play().catch(()=>{}); }
        if (lives <= 0) {
          gameOver();
          return;
        }
      }
      balls.splice(i,1);
    }
  }

  paddle.update();
}

function draw(){
  ctx.clearRect(0,0,canvas.width,canvas.height);

  if (state === 'TITLE') {
    // タイトル背景
    if (imgTitle.complete && imgTitle.naturalWidth > 0) {
      ctx.drawImage(imgTitle, 0,0, canvas.width, canvas.height);
    } else {
      ctx.fillStyle = '#000'; ctx.fillRect(0,0,canvas.width,canvas.height);
    }
    // タイトル文字
    ctx.font = UI.font(96);
    ctx.fillStyle = '#ffffff';
    UI.centerText('Pickleball Catch!', canvas.height*0.42);
    // Tap to Start（点滅）
    if (Math.floor(Date.now()/500)%2===0) {
      ctx.font = UI.font(56);
      UI.centerText('Tap to Start!', canvas.height*0.60, '#fff');
    }
    return;
  }

  // ゲーム・ゲームオーバー共通：背景
  if (state === 'GAMEOVER') {
    if (imgGameOver.complete && imgGameOver.naturalWidth > 0) {
      ctx.drawImage(imgGameOver, 0,0, canvas.width, canvas.height);
    } else if (imgBG.complete && imgBG.naturalWidth > 0) {
      ctx.drawImage(imgBG, 0,0, canvas.width, canvas.height);
    } else {
      ctx.fillStyle = '#000'; ctx.fillRect(0,0,canvas.width,canvas.height);
    }
  } else {
    if (imgBG.complete && imgBG.naturalWidth > 0) {
      ctx.drawImage(imgBG, 0,0, canvas.width, canvas.height);
    } else {
      ctx.fillStyle = '#87CEEB'; ctx.fillRect(0,0,canvas.width,canvas.height);
    }
  }

  if (state === 'PLAYING') {
    // ボール
    for (const b of balls) b.draw();
    // パドル
    paddle.draw();

    // UI（上部中央）
    ctx.textAlign = 'center';
    ctx.fillStyle = '#fff';
    ctx.font = UI.font(52);
    UI.centerText(`SCORE: ${score}`, canvas.height*0.07);
    ctx.fillStyle = 'pink';
    UI.centerText('♥'.repeat(lives), canvas.height*0.13);
  }

  if (state === 'GAMEOVER') {
    ctx.textAlign = 'center';
    ctx.fillStyle = '#fff';
    ctx.font = UI.font(72);
    UI.centerText('GAME OVER', canvas.height*0.45);
    ctx.font = UI.font(56);
    UI.centerText(`Your Score: ${score}`, canvas.height*0.56);
    UI.centerText(`High Score: ${highScore}`, canvas.height*0.63);
    if (Math.floor(Date.now()/500)%2===0) {
      ctx.font = UI.font(48);
      UI.centerText('Tap to Retry', canvas.height*0.80);
    }
  }
}

function loop(now){
  const dt = Math.min(0.033, (now - lastTime) / 1000); // 最大~33ms
  lastTime = now;
  update(dt);
  draw();
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

/* =========================
   ヘルパ
========================= */
function randRange(min, max){ return min + Math.random()*(max-min); }
</script>
</body>
</html>
