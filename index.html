<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Pickleball Catch!</title>
  <style>
    body { 
      margin: 0; 
      padding: 0;
      overflow: hidden; 
      background: black; 
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      min-height: 100dvh; /* å‹•çš„ãƒ“ãƒ¥ãƒ¼ãƒãƒ¼ãƒˆå¯¾å¿œ */
    }
    canvas { 
      display: block; 
      background: black;
      max-width: 100vw;
      max-height: 100vh;
      max-height: 100dvh; /* å‹•çš„ãƒ“ãƒ¥ãƒ¼ãƒãƒ¼ãƒˆå¯¾å¿œ */
    }
    #muteButton {
      position: absolute;
      top: 10px;
      right: 10px;
      z-index: 100;
      background: rgba(255,255,255,0.8);
      border: none;
      border-radius: 50%;
      width: 40px;
      height: 40px;
      font-size: 16px;
      cursor: pointer;
    }
    
    /* ãƒ•ãƒ«ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ç”¨ã‚¹ã‚¿ã‚¤ãƒ« */
    @media screen and (max-height: 500px) {
      body {
        min-height: 100dvh;
      }
    }
  </style>
  <link href="https://fonts.googleapis.com/css2?family=Fredoka+One&display=swap" rel="stylesheet">
</head>
<body>
  <button id="muteButton">ğŸ”Š</button>
  <canvas id="gameCanvas"></canvas>
  <script>
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");
    const muteBtn = document.getElementById("muteButton");

    // å‹•çš„æ¯”ç‡å¯¾å¿œè¨­å®š
    const MIN_ASPECT_RATIO = 16 / 9;  // æœ€å°æ¯”ç‡ï¼ˆPCç”¨ï¼‰
    const MAX_ASPECT_RATIO = 2.5 / 1; // æœ€å¤§æ¯”ç‡ï¼ˆè¶…ãƒ¯ã‚¤ãƒ‰ã‚¹ãƒãƒ›å¯¾å¿œï¼‰
    const BASE_WIDTH = 1600;
    const BASE_HEIGHT = 900;

    function resizeCanvas() {
      const windowWidth = window.innerWidth;
      const windowHeight = window.innerHeight;
      
      // ãƒ‡ãƒã‚¤ã‚¹ã®å®Ÿéš›ã®æ¯”ç‡ã‚’è¨ˆç®—
      const deviceAspectRatio = windowWidth / windowHeight;
      
      // æ¯”ç‡ã‚’åˆ¶é™å†…ã«åã‚ã‚‹
      const targetAspectRatio = Math.max(MIN_ASPECT_RATIO, 
                                Math.min(MAX_ASPECT_RATIO, deviceAspectRatio));
      
      let canvasWidth, canvasHeight;
      
      // å¸¸ã«ç”»é¢å…¨ä½“ã‚’ä½¿ç”¨ï¼ˆ95%ã®ãƒãƒ¼ã‚¸ãƒ³ï¼‰
      if (deviceAspectRatio > targetAspectRatio) {
        // æ¨ªãŒä½™ã‚‹å ´åˆ
        canvasHeight = windowHeight * 0.95;
        canvasWidth = canvasHeight * targetAspectRatio;
      } else {
        // ç¸¦ãŒä½™ã‚‹å ´åˆ
        canvasWidth = windowWidth * 0.98;
        canvasHeight = canvasWidth / targetAspectRatio;
        
        if (canvasHeight > windowHeight * 0.95) {
          canvasHeight = windowHeight * 0.95;
          canvasWidth = canvasHeight * targetAspectRatio;
        }
      }
      
      // Canvasã®å†…éƒ¨ã‚µã‚¤ã‚ºã‚’æ¯”ç‡ã«åˆã‚ã›ã¦å‹•çš„ã«èª¿æ•´
      const dynamicWidth = BASE_WIDTH;
      const dynamicHeight = Math.round(BASE_WIDTH / targetAspectRatio);
      
      canvas.width = dynamicWidth;
      canvas.height = dynamicHeight;
      canvas.style.width = canvasWidth + 'px';
      canvas.style.height = canvasHeight + 'px';
      
      // ã‚²ãƒ¼ãƒ å†…ã§ä½¿ç”¨ã™ã‚‹å®Ÿéš›ã®é«˜ã•ã‚’æ›´æ–°
      window.GAME_HEIGHT = dynamicHeight;
    }

    window.addEventListener("resize", resizeCanvas);
    resizeCanvas();

    // ã‚µã‚¦ãƒ³ãƒ‰ç®¡ç†ï¼ˆã‚·ãƒ³ãƒ—ãƒ«ç‰ˆï¼‰
    let isMuted = false;
    const bgm = new Audio("bgm.mp3");
    bgm.loop = true;
    bgm.volume = 0.2;
    
    const catchNormalSound = new Audio("catch_normal.wav");
    const catchRareSound = new Audio("catch_rare.wav");
    const missSound = new Audio("miss.mp3");
    const gameoverSound = new Audio("gameover.mp3");

    muteBtn.addEventListener("click", () => {
      isMuted = !isMuted;
      muteBtn.textContent = isMuted ? "ğŸ”‡" : "ğŸ”Š";
      
      if (isMuted) {
        bgm.pause();
        bgmDebugInfo = "BGM muted by user";
      } else {
        if (userInteracted) {
          startBGM();
        }
      }
      
      // ä»–ã®éŸ³å£°ã‚‚ãƒŸãƒ¥ãƒ¼ãƒˆè¨­å®š
      catchNormalSound.muted = isMuted;
      catchRareSound.muted = isMuted;
      missSound.muted = isMuted;
      gameoverSound.muted = isMuted;
    });

    // ç”»åƒèª­ã¿è¾¼ã¿
    const bgImg = new Image(); bgImg.src = "bg.png";
    const titleImg = new Image(); titleImg.src = "title.png";
    const paddleImg = new Image(); paddleImg.src = "paddle.png";
    
    const ballImgs = {};
    const ballColors = ["pink", "orange", "lightblue", "blue", "green", "yellow", "rainbow"];
    ballColors.forEach(color => {
      const img = new Image();
      img.src = `${color}.png`;
      ballImgs[color] = img;
    });

    // ã‚²ãƒ¼ãƒ çŠ¶æ…‹
    let gameState = "title";
    let score = 0, highScore = 0, lives = 3;
    let paddle = { x: 0, y: 0, width: 225, height: 60 }; // ãƒ‘ãƒ‰ãƒ«ã‚µã‚¤ã‚º1.5å€ï¼ˆ150x40 â†’ 225x60ï¼‰
    let balls = [];
    let effects = []; // ãƒ¬ã‚¤ãƒ³ãƒœãƒ¼ãƒœãƒ¼ãƒ«ç”¨ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
    let lastSpawn = 0, maxBalls = 2, startTime = null;

    // ãƒœãƒ¼ãƒ«è¨­å®šï¼ˆã‚µã‚¤ã‚ºèª¿æ•´ã€é€Ÿåº¦èª¿æ•´ï¼‰
    const BALL_SIZE = 180; // ãƒœãƒ¼ãƒ«ã‚µã‚¤ã‚ºã‚’180pxã«
    const ballTypes = {
      pink: { speed: 2, score: 1 },       // 2å›ºå®š
      orange: { speed: 4, score: 1 },     // 2+2=4
      lightblue: { speed: 6, score: 1 },  // 4+2=6
      blue: { speed: 8, score: 1 },       // 6+2=8
      green: { speed: 10, score: 1 },     // 8+2=10
      yellow: { speed: 12, score: 1 },    // 10+2=12
      rainbow: { speed: 25, score: 10, rare: true } // 25å›ºå®š
    };

    // å…¥åŠ›å‡¦ç†
    function getCanvasCoordinate(clientX, clientY) {
      const rect = canvas.getBoundingClientRect();
      const scaleX = BASE_WIDTH / rect.width;
      const scaleY = BASE_HEIGHT / rect.height;
      return {
        x: (clientX - rect.left) * scaleX,
        y: (clientY - rect.top) * scaleY
      };
    }

    window.addEventListener("mousemove", e => {
      if (gameState !== "playing") return;
      const coord = getCanvasCoordinate(e.clientX, e.clientY);
      paddle.x = coord.x - paddle.width / 2;
      clampPaddle();
    });

    window.addEventListener("touchmove", e => {
      if (gameState !== "playing") return;
      e.preventDefault();
      const touch = e.touches[0];
      const coord = getCanvasCoordinate(touch.clientX, touch.clientY);
      paddle.x = coord.x - paddle.width / 2;
      clampPaddle();
    }, { passive: false });

    function clampPaddle() {
      if (paddle.x < 0) paddle.x = 0;
      if (paddle.x + 300 > BASE_WIDTH) {  // ãƒ‘ãƒ‰ãƒ«ã‚µã‚¤ã‚º300ã«åˆã‚ã›ã¦èª¿æ•´
        paddle.x = BASE_WIDTH - 300;
      }
    }

    // BGMç®¡ç†ç”¨å¤‰æ•°
    let userInteracted = false;
    let bgmDebugInfo = "BGM waiting for interaction";

    // BGMé–‹å§‹é–¢æ•°ï¼ˆç¢ºå®Ÿã«å†ç”Ÿï¼‰
    function startBGM() {
      if (!isMuted) {
        bgmDebugInfo = "Starting BGM...";
        bgm.currentTime = 0;
        
        // å¼·åˆ¶çš„ã«BGMå†ç”Ÿã‚’è©¦è¡Œ
        const playPromise = bgm.play();
        if (playPromise !== undefined) {
          playPromise.then(() => {
            bgmDebugInfo = "BGM playing successfully";
            console.log("BGM started successfully");
          }).catch(error => {
            bgmDebugInfo = `BGM error: ${error.name}`;
            console.log("BGM failed:", error);
            
            // çŸ­æ™‚é–“å¾Œã«å†è©¦è¡Œ
            setTimeout(() => {
              bgm.play().then(() => {
                bgmDebugInfo = "BGM retry successful";
              }).catch(() => {
                bgmDebugInfo = "BGM retry failed";
              });
            }, 200);
          });
        }
      } else {
        bgmDebugInfo = "BGM muted";
      }
    }

    canvas.addEventListener("click", e => {
      e.preventDefault();
      
      if (!userInteracted) {
        userInteracted = true;
        bgmDebugInfo = "First click - starting BGM";
        startBGM();
      }
      
      const coord = getCanvasCoordinate(e.clientX, e.clientY);
      
      if (gameState === "title") {
        startGame();
      } else if (gameState === "gameover") {
        startGame();
      }
    });

    canvas.addEventListener("touchstart", e => {
      e.preventDefault();
      
      if (!userInteracted) {
        userInteracted = true;
        bgmDebugInfo = "First touch - starting BGM";
        startBGM();
      }
      
      const touch = e.touches[0];
      const coord = getCanvasCoordinate(touch.clientX, touch.clientY);
      
      if (gameState === "title") {
        startGame();
      } else if (gameState === "gameover") {
        startGame();
      }
    });

    function startGame() {
      gameState = "playing";
      score = 0; 
      lives = 3;
      balls = [];
      effects = [];
      maxBalls = 2;
      startTime = Date.now();
      lastSpawn = 0;
      
      // ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ã‚µã‚¦ãƒ³ãƒ‰ã‚’åœæ­¢
      gameoverSound.pause();
      gameoverSound.currentTime = 0;
      
      // ã‚²ãƒ¼ãƒ é–‹å§‹æ™‚ã«BGMçŠ¶æ…‹ç¢ºèªãƒ»å†ç”Ÿ
      bgmDebugInfo = "Game starting...";
      
      if (!isMuted && userInteracted) {
        // BGMãŒåœæ­¢ã—ã¦ã„ã‚‹å ´åˆã¯å†é–‹
        if (bgm.paused) {
          bgmDebugInfo = "Restarting paused BGM";
          bgm.currentTime = 0;
          bgm.play().then(() => {
            bgmDebugInfo = "BGM restarted in game";
          }).catch(error => {
            bgmDebugInfo = `BGM restart failed: ${error.name}`;
          });
        } else {
          bgmDebugInfo = "BGM already playing";
        }
      }
    }

    // ãƒœãƒ¼ãƒ«å‡ºç¾ãƒ«ãƒ¼ãƒ«
    function getAvailableColors(elapsed) {
      const colors = [];
      
      // åºç›¤ï¼ˆ0ã€œ15ç§’ï¼‰
      colors.push("orange", "lightblue", "blue");
      
      // 15ç§’ã€œ30ç§’ï¼šç·‘è¿½åŠ 
      if (elapsed >= 15) colors.push("green");
      
      // 30ç§’ã€œ45ç§’ï¼šãƒ”ãƒ³ã‚¯è¿½åŠ 
      if (elapsed >= 30) colors.push("pink");
      
      // 45ç§’ã€œ60ç§’ï¼šé»„è¿½åŠ 
      if (elapsed >= 45) colors.push("yellow");
      
      return colors;
    }

    function spawnBall() {
      const elapsed = (Date.now() - startTime) / 1000;
      
      // ãƒ¬ã‚¤ãƒ³ãƒœãƒ¼ã¯å¸¸æ™‚ä½ç¢ºç‡ï¼ˆ3%ï¼‰
      if (Math.random() < 0.03) {
        const ball = { 
          x: Math.random() * (BASE_WIDTH - 180), 
          y: -180, 
          size: 180, 
          type: "rainbow" 
        };
        balls.push(ball);
        return;
      }
      
      // é€šå¸¸ã®ãƒœãƒ¼ãƒ«
      const availableColors = getAvailableColors(elapsed);
      const color = availableColors[Math.floor(Math.random() * availableColors.length)];
      
      balls.push({ 
        x: Math.random() * (BASE_WIDTH - 180), 
        y: -180, 
        size: 180, 
        type: color 
      });
    }

    // ãƒ¬ã‚¤ãƒ³ãƒœãƒ¼ãƒœãƒ¼ãƒ«ç”¨ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
    function addRainbowEffect(ball) {
      for (let i = 0; i < 3; i++) {
        effects.push({
          x: ball.x + ball.size/2 + (Math.random() - 0.5) * 40,
          y: ball.y + ball.size/2,
          size: Math.random() * 8 + 4,
          alpha: 1,
          color: `hsl(${Math.random() * 360}, 100%, 70%)`
        });
      }
    }

    function updateEffects() {
      effects.forEach((effect, i) => {
        effect.y += 2;
        effect.alpha -= 0.03;
        if (effect.alpha <= 0) {
          effects.splice(i, 1);
        }
      });
    }

    function drawEffects() {
      effects.forEach(effect => {
        ctx.save();
        ctx.globalAlpha = effect.alpha;
        ctx.fillStyle = effect.color;
        ctx.beginPath();
        ctx.arc(effect.x, effect.y, effect.size, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      });
    }

    // ãƒ‘ãƒ‰ãƒ«ã¨ãƒœãƒ¼ãƒ«ã®å½“ãŸã‚Šåˆ¤å®šï¼ˆå¤–æ ã®ã¿ã€ãƒ‘ãƒ‰ãƒ«ç”»åƒã®å®Ÿéš›ã®å¢ƒç•Œã«åˆã‚ã›ã¦èª¿æ•´ï¼‰
    function checkCollision(ball, paddle) {
      const ballLeft = ball.x;
      const ballRight = ball.x + ball.size;
      const ballTop = ball.y;
      const ballBottom = ball.y + ball.size;
      
      const paddleLeft = paddle.x;
      const paddleRight = paddle.x + 300; // ãƒ‘ãƒ‰ãƒ«ã®å¹…
      const paddleTop = paddle.y + 25; // ãƒ‘ãƒ‰ãƒ«ç”»åƒã®å®Ÿéš›ã®ä¸Šç«¯ï¼ˆé€æ˜éƒ¨åˆ†ã‚’é™¤ãã€ã•ã‚‰ã«ä¸‹ã«èª¿æ•´ï¼‰
      const paddleBottom = paddle.y + 80; // ãƒ‘ãƒ‰ãƒ«ã®é«˜ã•
      
      // ãƒœãƒ¼ãƒ«ãŒãƒ‘ãƒ‰ãƒ«ã®ç¯„å›²å†…ã«ã‚ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
      if (ballRight < paddleLeft || ballLeft > paddleRight || 
          ballBottom < paddleTop || ballTop > paddleBottom) {
        return false;
      }
      
      // å¤–æ ã¨ã®å½“ãŸã‚Šåˆ¤å®š
      // ä¸Šé¢ã¨ã®å½“ãŸã‚Šåˆ¤å®šï¼ˆãƒ‘ãƒ‰ãƒ«ç”»åƒã®å®Ÿéš›ã®å¢ƒç•Œï¼‰
      if (ballBottom >= paddleTop && ballTop < paddleTop && 
          ballRight > paddleLeft && ballLeft < paddleRight) {
        return true;
      }
      
      // å·¦é¢ã¨ã®å½“ãŸã‚Šåˆ¤å®š
      if (ballRight >= paddleLeft && ballLeft < paddleLeft && 
          ballBottom > paddleTop && ballTop < paddleBottom) {
        return true;
      }
      
      // å³é¢ã¨ã®å½“ãŸã‚Šåˆ¤å®š
      if (ballLeft <= paddleRight && ballRight > paddleRight && 
          ballBottom > paddleTop && ballTop < paddleBottom) {
        return true;
      }
      
      return false;
    }

    function update() {
      if (!startTime) startTime = Date.now();
      const elapsed = (Date.now() - startTime) / 1000;

      // ãƒœãƒ¼ãƒ«å‡ºç¾åˆ¶å¾¡ï¼ˆè¶…ã‚·ãƒ“ã‚¢è¨­å®šï¼‰
      if (elapsed - lastSpawn > 0.5 && balls.length < maxBalls) {
        spawnBall(); 
        lastSpawn = elapsed;
      }
      
      // å¼·åˆ¶å‡ºç¾ã‚·ã‚¹ãƒ†ãƒ ï¼šæœ€å¤§æ•°ã«é”ã—ã¦ã„ãªã„å ´åˆã¯ç©æ¥µçš„ã«å‡ºç¾
      if (balls.length < maxBalls - 1 && elapsed - lastSpawn > 0.2) {
        spawnBall();
        lastSpawn = elapsed;
      }
      
      // è¶…å¼·åˆ¶å‡ºç¾ï¼šæœ€å¤§æ•°ã®åŠåˆ†ä»¥ä¸‹ãªã‚‰å³åº§ã«å‡ºç¾
      if (balls.length < maxBalls / 2) {
        spawnBall();
        lastSpawn = elapsed;
      }
      
      // é›£æ˜“åº¦é€²è¡Œï¼ˆ15ç§’ã”ã¨ã«+1å€‹ã€150ç§’ã§æœ€å¤§12å€‹ã¾ã§ï¼‰
      // 0ç§’:2å€‹ â†’ 15ç§’:3å€‹ â†’ 30ç§’:4å€‹ â†’ 45ç§’:5å€‹ â†’ 60ç§’:6å€‹ â†’ 75ç§’:7å€‹ â†’ 90ç§’:8å€‹ â†’ 105ç§’:9å€‹ â†’ 120ç§’:10å€‹ â†’ 135ç§’:11å€‹ â†’ 150ç§’:12å€‹
      const newMaxBalls = Math.min(12, 2 + Math.floor(elapsed / 15));
      if (newMaxBalls > maxBalls) {
        maxBalls = newMaxBalls;
      }

      paddle.y = (window.GAME_HEIGHT || BASE_HEIGHT) - 120;
      balls.forEach((ball, i) => {
        ball.y += ballTypes[ball.type].speed;
        
        // ãƒ¬ã‚¤ãƒ³ãƒœãƒ¼ãƒœãƒ¼ãƒ«ã«ã‚¨ãƒ•ã‚§ã‚¯ãƒˆè¿½åŠ 
        if (ball.type === "rainbow") {
          addRainbowEffect(ball);
        }
        
        // å½“ãŸã‚Šåˆ¤å®šï¼ˆå¤–æ ã®ã¿ï¼‰
        if (checkCollision(ball, paddle)) {
          score += ballTypes[ball.type].score;
          
          // ã‚µã‚¦ãƒ³ãƒ‰å†ç”Ÿï¼ˆã‚¹ãƒãƒ›å¯¾å¿œæ”¹å–„ï¼‰
          const sound = ball.type === "rainbow" ? catchRareSound : catchNormalSound;
          if (!isMuted) {
            try {
              const audioClone = sound.cloneNode();
              audioClone.volume = 0.7; // éŸ³é‡èª¿æ•´
              audioClone.currentTime = 0;
              audioClone.play().catch(e => console.log("Audio play failed:", e));
            } catch (e) {
              console.log("Audio clone failed:", e);
            }
          }
          
          balls.splice(i, 1);
        } else if (ball.y > (window.GAME_HEIGHT || BASE_HEIGHT)) {
          // ãƒ©ã‚¤ãƒ•æ¸›å°‘ï¼ˆãƒ¬ã‚¤ãƒ³ãƒœãƒ¼ã¯é™¤ãï¼‰
          if (!ballTypes[ball.type].rare) {
            lives--;
            if (!isMuted) {
              const missClone = missSound.cloneNode();
              missClone.play();
            }
            if (lives <= 0) gameOver();
          }
          balls.splice(i, 1);
        }
      });

      updateEffects();
    }

    function gameOver() {
      gameState = "gameover";
      // BGMã¯åœæ­¢ã›ãšã«ç¶™ç¶šå†ç”Ÿ
      if (!isMuted) {
        gameoverSound.currentTime = 0; 
        gameoverSound.play();
      }
      if (score > highScore) highScore = score;
    }

    function draw() {
      const gameHeight = window.GAME_HEIGHT || BASE_HEIGHT;
      
      // èƒŒæ™¯ï¼ˆå‹•çš„ã‚µã‚¤ã‚ºå¯¾å¿œï¼‰
      ctx.drawImage(bgImg, 0, 0, BASE_WIDTH, gameHeight);
      
      // ãƒ‘ãƒ‰ãƒ«ï¼ˆä¸‹ç«¯ã‹ã‚‰ã®ç›¸å¯¾ä½ç½®ï¼‰
      paddle.y = gameHeight - 120;
      ctx.drawImage(paddleImg, paddle.x, paddle.y, 300, 80);
      
      // ãƒœãƒ¼ãƒ«
      balls.forEach(ball => {
        ctx.drawImage(ballImgs[ball.type], ball.x, ball.y, ball.size, ball.size);
      });
      
      // ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
      drawEffects();
      
      // UI
      ctx.fillStyle = "white";
      ctx.font = "64px 'Fredoka One'";
      ctx.textAlign = "center";
      ctx.fillText("Score: " + score, BASE_WIDTH/2, 80);
      
      // ãƒ©ã‚¤ãƒ•è¡¨ç¤ºï¼ˆèµ¤è‰²ã€2å€ã‚µã‚¤ã‚ºã€ä½ç½®ã‚’ä¸‹ã«èª¿æ•´ï¼‰
      ctx.fillStyle = "red";
      ctx.font = "96px 'Fredoka One'";
      ctx.fillText("â™¥".repeat(lives), BASE_WIDTH/2, 180);
      
      // BGMãƒ‡ãƒãƒƒã‚°æƒ…å ±ã‚’ã‚²ãƒ¼ãƒ ä¸­ã‚‚è¡¨ç¤º
      ctx.fillStyle = "yellow";
      ctx.font = "20px 'Fredoka One'";
      ctx.textAlign = "left";
      ctx.fillText(`BGM: ${bgmDebugInfo}`, 50, gameHeight - 50);
    }

    function drawTitleScreen() {
      const gameHeight = window.GAME_HEIGHT || BASE_HEIGHT;
      ctx.drawImage(titleImg, 0, 0, BASE_WIDTH, gameHeight);
      
      ctx.fillStyle = "#ff66cc"; // ãƒ”ãƒ³ã‚¯è‰²
      ctx.font = "120px 'Fredoka One'";
      ctx.textAlign = "center";
      ctx.fillText("Pickleball Catch!", BASE_WIDTH/2, gameHeight/2 - 60);
      
      // ç‚¹æ»…åŠ¹æœ
      if (Math.floor(Date.now() / 500) % 2 === 0) {
        ctx.fillStyle = "white";
        ctx.font = "64px 'Fredoka One'";
        ctx.fillText("Tap to Start!", BASE_WIDTH/2, gameHeight/2 + 60);
      }
      
      // BGMãƒ‡ãƒãƒƒã‚°æƒ…å ±è¡¨ç¤º
      ctx.fillStyle = "yellow";
      ctx.font = "24px 'Fredoka One'";
      ctx.textAlign = "left";
      ctx.fillText(`BGM Status: ${bgmDebugInfo}`, 50, 50);
      ctx.fillText(`Mute Button: ${isMuted ? 'Muted' : 'Unmuted'}`, 50, 80);
    }

    function drawGameOver() {
      const gameHeight = window.GAME_HEIGHT || BASE_HEIGHT;
      
      ctx.fillStyle = "rgba(0,0,0,0.7)";
      ctx.fillRect(0, 0, BASE_WIDTH, gameHeight);
      
      ctx.textAlign = "center";
      
      // GAME OVER
      ctx.fillStyle = "#ff66cc"; // ãƒ”ãƒ³ã‚¯
      ctx.font = "140px 'Fredoka One'";
      ctx.fillText("GAME OVER", BASE_WIDTH/2, gameHeight/2 - 120);
      
      // ã‚¹ã‚³ã‚¢
      ctx.fillStyle = "#ff66cc"; // ãƒ”ãƒ³ã‚¯
      ctx.font = "80px 'Fredoka One'";
      ctx.fillText("Score: " + score, BASE_WIDTH/2, gameHeight/2 - 20);
      
      // ãƒã‚¤ã‚¹ã‚³ã‚¢
      ctx.fillStyle = "#ffcc00"; // é»„è‰²
      ctx.fillText("High Score: " + highScore, BASE_WIDTH/2, gameHeight/2 + 60);
      
      // ã‚¿ãƒƒãƒ—ã§ãƒªã‚¹ã‚¿ãƒ¼ãƒˆã®æŒ‡ç¤ºï¼ˆç‚¹æ»…åŠ¹æœï¼‰
      if (Math.floor(Date.now() / 500) % 2 === 0) {
        ctx.fillStyle = "white";
        ctx.font = "48px 'Fredoka One'";
        ctx.fillText("Tap anywhere to restart", BASE_WIDTH/2, gameHeight/2 + 150);
      }
    }

    function loop() {
      ctx.clearRect(0, 0, BASE_WIDTH, BASE_HEIGHT);
      
      if (gameState === "title") {
        drawTitleScreen();
      } else if (gameState === "playing") {
        update();
        draw();
      } else if (gameState === "gameover") {
        drawGameOver();
      }
      
      requestAnimationFrame(loop);
    }

    loop();
  </script>
</body>
</html>